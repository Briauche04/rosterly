// app/manager/edit/page.tsx
"use client";

import { useEffect, useMemo, useState } from "react";
import { createBrowserClient } from "@supabase/ssr";

// ---- minimal inline supabase client (no extra files) ----
const supabase = createBrowserClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

// Monday-based week labels
const WD = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"] as const;

function mondayOf(date: Date) {
  const d = new Date(date);
  const day = (d.getDay() + 6) % 7; // 0=Mon
  d.setDate(d.getDate() - day);
  d.setHours(0, 0, 0, 0);
  return d;
}
function isoDate(d: Date) {
  return d.toISOString().slice(0, 10);
}

type Employee = { id: string; full_name: string | null };
type Submission = { id: string; employee_id: string; week_start: string };
type SubmissionDay = { id: string; submission_id: string; day: number; selected: boolean };

type Row = {
  employee: Employee;
  submission: Submission | null;
  days: SubmissionDay[]; // one per 0..6 if present
};

export default function Page({ searchParams }: { searchParams?: { week?: string } }) {
  const initialWeek = (() => {
    if (searchParams?.week) return searchParams.week;
    return isoDate(mondayOf(new Date()));
  })();

  return (
    <main className="p-6 space-y-4">
      <WeekSwitcher weekStart={initialWeek} />
      <ManagerEditTable weekStart={initialWeek} />
    </main>
  );
}

function WeekSwitcher({ weekStart }: { weekStart: string }) {
  const d = new Date(weekStart + "T00:00:00");
  const prev = new Date(d); prev.setDate(prev.getDate() - 7);
  const next = new Date(d); next.setDate(next.getDate() + 7);
  const fmt = (x: Date) => isoDate(x);

  return (
    <div className="flex items-center gap-2">
      <a className="px-3 py-2 rounded-xl border" href={`?week=${fmt(prev)}`}>← Prev</a>
      <div className="px-3 py-2 rounded-xl border bg-gray-50">Week of {weekStart}</div>
      <a className="px-3 py-2 rounded-xl border" href={`?week=${fmt(next)}`}>Next →</a>
    </div>
  );
}

function ManagerEditTable({ weekStart }: { weekStart: string }) {
  const [rows, setRows] = useState<Row[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function load() {
    setLoading(true);
    setError(null);

    // 1) employees
    const { data: employees, error: empErr } = await supabase
      .from("employees")
      .select("id, full_name")
      .order("full_name", { ascending: true });
    if (empErr) { setError(empErr.message); setLoading(false); return; }

    // 2) submissions for this week
    const { data: submissions, error: subErr } = await supabase
      .from("submissions")
      .select("id, employee_id, week_start")
      .eq("week_start", weekStart);
    if (subErr) { setError(subErr.message); setLoading(false); return; }

    // 3) submission_days for those submissions
    const subIds = (submissions ?? []).map((s) => s.id);
    let days: SubmissionDay[] = [];
    if (subIds.length) {
      const { data: dd, error: dayErr } = await supabase
        .from("submission_days")
        .select("id, submission_id, day, selected")
        .in("submission_id", subIds);
      if (dayErr) { setError(dayErr.message); setLoading(false); return; }
      days = (dd ?? []) as SubmissionDay[];
    }

    // Group days by submission_id
    const bySub = new Map<string, SubmissionDay[]>();
    for (const d of days) {
      const arr = bySub.get(d.submission_id) ?? [];
      arr.push(d);
      bySub.set(d.submission_id, arr);
    }

    // Build table rows
    const nextRows: Row[] = (employees ?? []).map((emp) => {
      const submission = (submissions ?? []).find((s) => s.employee_id === emp.id) ?? null;
      const d = submission ? (bySub.get(submission.id) ?? []).sort((a, b) => a.day - b.day) : [];
      return { employee: emp, submission, days: d };
    });

    setRows(nextRows);
    setLoading(false);
  }

  useEffect(() => { load(); /* eslint-disable-next-line */ }, [weekStart]);

  function toggleLocal(rowIdx: number, dayIdx: number) {
    setRows((prev) => {
      const copy = structuredClone(prev);
      const row = copy[rowIdx];
      if (!row || !row.submission) return prev;

      let cell = row.days.find((d) => d.day === dayIdx);
      if (!cell) {
        // create a local placeholder; DB will replace ID on save
        cell = {
          id: crypto.randomUUID(),
          submission_id: row.submission.id,
          day: dayIdx,
          selected: true,
        };
        row.days.push(cell);
        row.days.sort((a, b) => a.day - b.day);
      } else {
        cell.selected = !cell.selected;
      }
      return copy;
    });
  }

  async function saveOne(rowIdx: number, dayIdx: number) {
    const row = rows[rowIdx];
    if (!row?.submission) return;
    const cell = row.days.find((d) => d.day === dayIdx);
    if (!cell) return;

    setSaving(true);
    setError(null);
    try {
      const { data, error } = await supabase
        .from("submission_days")
        .upsert(
          [{ id: cell.id, submission_id: cell.submission_id, day: cell.day, selected: cell.selected }],
          { onConflict: "submission_id,day" } as any
        )
        .select();

      if (error) throw error;
      if (data && data[0]) {
        // normalize local temp id with DB row
        setRows((prev) => {
          const copy = structuredClone(prev);
          const r = copy[rowIdx];
          const i = r.days.findIndex((d) => d.day === dayIdx);
          if (i >= 0) r.days[i] = data[0] as SubmissionDay;
          return copy;
        });
      }
    } catch (e: any) {
      setError(e.message ?? "Save failed");
    } finally {
      setSaving(false);
    }
  }

  async function saveAll() {
    setSaving(true);
    setError(null);
    try {
      const payload = rows
        .filter((r) => r.submission)
        .flatMap((r) => r.days)
        .map((d) => ({ id: d.id, submission_id: d.submission_id, day: d.day, selected: d.selected }));

      if (payload.length) {
        const { error } = await supabase
          .from("submission_days")
          .upsert(payload, { onConflict: "submission_id,day" } as any);
        if (error) throw error;
      }
    } catch (e: any) {
      setError(e.message ?? "Save failed");
    } finally {
      setSaving(false);
      load(); // refresh IDs from DB
    }
  }

  const missing = useMemo(() => rows.filter((r) => !r.submission).length, [rows]);

  if (loading) return <div className="p-6 text-sm">Loading…</div>;

  return (
    <div className="w-full p-4">
      {error && <div className="mb-3 text-red-600">{error}</div>}

      <div className="flex items-end justify-between gap-4 mb-4">
        <div>
          <h2 className="text-xl font-semibold">Edit schedule</h2>
          <p className="text-sm text-neutral-500">Week starting {weekStart}</p>
          {missing > 0 && (
            <p className="text-xs text-amber-600 mt-1">
              {missing} employee(s) have not submitted availability for this week.
            </p>
          )}
        </div>
        <button
          onClick={saveAll}
          disabled={saving}
          className="px-3 py-2 rounded-xl bg-black text-white disabled:opacity-50"
        >
          {saving ? "Saving…" : "Save all"}
        </button>
      </div>

      <div className="overflow-auto border rounded-xl">
        <table className="min-w-[720px] w-full text-sm">
          <thead className="bg-gray-50">
            <tr>
              <th className="text-left p-3 w-64">Employee</th>
              {WD.map((d) => (
                <th key={d} className="p-3 text-center">{d}</th>
              ))}
            </tr>
          </thead>
          <tbody>
            {rows.map((row, rowIdx) => (
              <tr key={row.employee.id} className="border-t">
                <td className="p-3 font-medium">{row.employee.full_name ?? "Unnamed"}</td>
                {WD.map((_, dayIdx) => {
                  const cell = row.days.find((d) => d.day === dayIdx);
                  const checked = cell?.selected ?? false;
                  const disabled = !row.submission;
                  return (
                    <td key={dayIdx} className="p-2 text-center">
                      <label className={`inline-flex items-center gap-2 ${disabled ? "opacity-40" : ""}`}>
                        <input
                          type="checkbox"
                          className="h-4 w-4"
                          checked={checked}
                          disabled={disabled}
                          onChange={() => toggleLocal(rowIdx, dayIdx)}
                        />
                        <button
                          type="button"
                          disabled={disabled}
                          onClick={() => saveOne(rowIdx, dayIdx)}
                          className="text-xs underline disabled:no-underline disabled:cursor-not-allowed"
                        >
                          save
                        </button>
                      </label>
                    </td>
                  );
                })}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}